

# Higher-Order DisCoCat

_(Peirce-Lambek-Montague semantics)_

Alexis Toumi and Giovanni de Felice

_Quantum - Quantum Compositional Intelligence_

_17 Beaumont street, OX1 2NA Oxford, UK_

###### Abstract

We propose a new definition of higher-order DisCoCat (categorical compositional distributional) models where the meaning of a word is not a diagram, but a diagram-valued higher-order function. Our models can be seen as a variant of Montague semantics based on a lambda calculus where the primitives act on string diagrams rather than logical formulae. As a special case, we show how to translate from the Lambek calculus into Peirce's system beta for first-order logic. This allows us to give a purely diagrammatic treatment of higher-order and non-linear processes in natural language semantics: adverbs, prepositions, negation and quantifiers. The theoretical definition presented in this article comes with a proof-of-concept implementation in DisCoPy, the Python library for string diagrams.

## Introduction

DisCoCat [1, 2] (Categorical Compositional Distributional) models are structure-preserving maps which send _grammatical types to vector spaces_ and _grammatical structures to linear maps_. Concretely, the meaning of words is given by tensors with shapes induced by their grammatical types; the meaning of sentences is given by contracting the tensor networks induced by their grammatical structure. _String diagrams_ provide an intuitive graphical language to visualise and reason formally about the evaluation of DisCoCat models; which can be formalised in terms of _functors_$F:\mathbf{G}\rightarrow\mathbf{Vect}$ from the category generated by a formal grammar $\mathbf{G}$ to the monoidal category $\mathbf{Vect}$ of vector spaces and linear maps with the tensor product [3, SS2.5].

Although this functorial definition applies equally to any kind of formal grammar, most of the DisCoCat literature focuses on _pregroup grammars_ and more generally on _categorical grammars_ such as the _Lambek calculus_[4, 5] and _combinatory categorial grammars_ (CCG) [6]. In that case, $\mathbf{G}$ is a _closed monoidal category_ and the DisCoCat models $F:\mathbf{G}\rightarrow\mathbf{Vect}$ map grammatical structures to the closed structure of $\mathbf{Vect}$ in a canonical way. In practice, this means that once the meaning of each word is computed from a dataset, the meaning of any new grammatical sentence can be computed automatically from its grammatical structure.

While assigning vectors to words of _atomic types_ like common nouns was already a standard technique in the field of distributional semantics, the main novelty of the DisCoCat framework lied in its treatment of _complex types_ like adjectives, verbs, etc. If the atomic type $n$ for common nouns is assigned a vector space $F(n)=N$, the complex type $n\gets n$ for adjectives (modifying nouns on their right) is mapped to the tensor product $F(n\gets n)=N\otimes N^{\star}$: _adjectives are not vectors, they are linear maps._ Now if we play the same game with the type for adverbs (modifying adjectives on their right) we get tensors of order four: $F((n\gets n)\leftarrow(n\gets n))=N\otimes N^{\star}\otimes N^{\star}\otimes N$. Not only does this lead to unreasonably large representations -- if we want 1000 parameters for each noun, we need 1000 billion parameters _for each adverb_ -- but we argue that it also misses the point of such higher-order types altogether.

Because the codomain of DisCoCat models $F:\mathbf{G}\to\mathbf{Vect}$ is a _compact-closed category_, any second-order type $a\leftarrow(b\gets c)$ is squashed down to the same vector space $A\otimes(B\otimes C^{\star})^{\star}\simeq A\otimes C\otimes B^{\star}$ as the first-order types $a(c\gets b)$ and $(ac)\gets b$. This collapse down to first-order makes it impossible to express linguistic phenomena that are inherently higher-order1 such as negation, disjunction and universal quantification. Indeed, the variant of DisCoCat models valued in the compact closed category of relations $\mathbf{Rel}$ are as expressive as _regular logic_, the fragment of first-order logic generated by truth, conjunction and existential quantification [7]. The one missing ingredient to get from regular logic to all of first-order logic is _negation_, which cannot be expressed in terms of relational composition. In short, _negation cannot be a relation_ but it can be expressed as a non-linear, higher-order function which maps relations to relations.

Footnote 1: Here we mean higher-order in the sense of functions taking functions as input, although we are still within the realm of first-order logic with quantifiers over variables rather than predicates. Note that there is also a third ambiguous meaning of order: an element of $A\otimes C\otimes B^{\star}$ is called a tensor of order three but it is still a first-order function when seen as a linear map $A\otimes C\to B$.

This observation can be traced back to Peirce [8]'s _system beta_ and his _existential graphs_ which are both the first examples of string diagrams and arguably the first axiomatisation of first-order logic. In today's terminology, Peirce defined string diagrams with _swaps_, _cups_, _caps_, _spiders_ -- which Peirce called _lines of identity_ -- and a _unary operator on homsets_ for negation represented as a circle that he called _cut_. Existential graphs come with graphical equations that are sound and complete for first-order logic, see [9, 10] for a categorical presentation.

The use of higher-order functions for natural language semantics is the basis of _Montague semantics_[11]. Concretely, the meaning of a word is given by a term in the simply-typed lambda calculus with the symbols of first-order logic2 taken as primitives; the meaning of a sentence is given by composing these lambda terms together to get a closed formula. Abstractly, this can be formalised as a closed monoidal functor $F:\mathbf{G}\to\Lambda L$ where $\mathbf{G}$ is a categorial grammar and $L$ is the language of first-order logic (predicates, negation, conjunction, quantifiers, etc.) seen as the presentation of a cartesian closed category $\Lambda L$[3, SS2.2]. Interpretations of the logic in a model then induce closed monoidal functors $\llbracket\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\! \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\! \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\! \!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\!\! \!\!\! tification. On the other, we have the higher-order functions of Montague semantics, but where the resulting logical formulae are not easily amenable to machine learning and computationally intractable (e.g. equivalence of first-order logic formulae is undecidable). What we propose is to get the best of both worlds. As in Montague semantics, we assign a simply-typed lambda term to each word, but now with diagram-valued operations as primitives. The meaning of a sentence is given by composing these lambda terms together to get a diagram which can be interpreted in **Vect**, as in a DisCoCat model, or in fact in any monoidal category **C**.

We propose to go from standard DisCoCat models $F:\textbf{G}\rightarrow\textbf{Vect}$ to _higher-order DisCoCat_ (HO-DisCoCat) models defined as closed monoidal functors $F:\textbf{G}\rightarrow\Lambda D$ where $D$ is the language of _string diagrams_ (boxes, identity, composition, tensor, etc.) again seen as the signature for a free cartesian closed category $\Lambda D$. The closed monoidal functors $\llbracket-\rrbracket:\Lambda D\rightarrow\textbf{Set}$ now correspond precisely to interpretations of the diagrams in any monoidal category **C**. Thus we can replace **Vect** by any monoidal category **C**, which need not be compact closed. This allows many new variants of DisCoCat models, for example based on neural networks or stochastic processes. It also has potential applications in quantum natural language processing [12] (QNLP) where the compact closed structure comes at the cost of exponentially low probability of success [13].

The rest of this article is organised as follows. Section 1 gives a first toy example of a higher-order process which cannot be accounted for in these standard DisCoCat models. Section 2 formulates a standard example of Montague semantics in terms of a closed monoidal functor $F:\textbf{G}\rightarrow\Lambda L$. Section 3 contains our main definition: HO-DisCoCat models as closed monoidal functors $F:\textbf{G}\rightarrow\Lambda D$. Section 4 shows how our models can be extended to monoidal categories with additional operations, which we use to model arbitrary adverbs depicted as _boxes with holes_ that can hold diagrams themselves. Section 5 defines a HO-DisCoCat model which we call _Peirce-Lambek-Montague_ semantics, where the diagrams are existential graphs. This closes the conjecture opened in [1]: DisCoCat models valued in **Rel** are not as expressive as Montague semantics, but higher-order DisCoCat models are. Appendix A showcases an implementation of this Peirce-Lambek-Montague semantics using DisCoPy [14], the Python toolkit for computing with string diagrams.

## 1 A toy example: "very big" = "big big"

To keep things concrete, we delay the formal definition of HO-DisCoCat models and start with a simple example of a higher-order function: the function $\texttt{twice}:(X\to X)\rightarrow(X\to X)$ which takes a function and applies it twice, i.e. $\texttt{twice}=\lambda fx.ffx$. In our toy model of semantics:

* the noun "car" is sent to some vector $F(\text{car})\in N$ drawn as a box with one wire out,
* the adjective "big" is sent to the function which takes a vector and post-compose it with some linear map $F(\text{big})=\lambda x.B\circ x$ drawn as a box with one wire in and one wire out,
* the adverb "very" is sent to the non-linear, higher-order function $F(\text{very})=\texttt{twice}$.

We can now apply it to the noun phrase "very big car" and check that indeed it has the same semantics as "big big car". The image of the functor $F:\textbf{G}\rightarrow\Lambda D$ on a syntax tree can be visualised by annotating each node with a lambda term with string diagrams as primitives. The leaves of the tree contain the lambda terms for each word. Each binary node is the application of a subtree of type $x\gets y$ on the left ($y\to x$ on the right) to one of type $y$ on the other side.

**Remark**.: _The following notation for syntax trees annotated with their semantics is borrowed from the one used for CCG derivations [15], except that we use string diagrams rather than the traditional predicate-argument structure. Note that these are not quite string diagrams in the category $\mathbf{Set}$: boxes are not labeled with their corresponding function, but with the result of applying this function to its arguments._

\begin{tabular}{|c|c|c|} \hline \multicolumn{1}{|c|}{Very} & \multicolumn{1}{c|}{big}{car} \\ \hline $\lambda fx\cdot ffx$ & $\lambda x\cdot$ & $\lambda x\cdot$ & $B$ \\ \hline $(n\gets n)\leftarrow(n\gets n)$ & $n\gets n$ & $n$ \\ \hline $\lambda x\cdot$ & $x\cdot$ & $B$ & $B$ \\ \hline $n\gets n$ & $n\gets n$ & \\ \hline \end{tabular}

Due to the no-cloning theorem, copying an adjective in this way is not possible in a standard DisCoCat model $F:\mathbf{G}\rightarrow\mathbf{Vect}$. Indeed, there can be no linear map $\mathtt{twice}:X\otimes X^{\star}\to X\otimes X^{\star}$ such that $\mathtt{twice}(f)=f\circ f$ for all linear maps $f:X\to X$. How can our higher-order DisCoCat model $F:\mathbf{G}\rightarrow\Lambda D$ get away with such a fundamental law of physics? To clear any such confusion, it is important to distinguish the three categories at play in the example above:

1. The (white) closed monoidal category $\mathbf{G}$ generated by arrows $w\to t$ for each word $w$ of type $t$. The arrows $w_{1}\ldots w_{n}\to s$ are the syntax trees of grammatical sentences.
2. The (green) cartesian closed category $\Lambda D$ where the arrows are lambda terms with the composition of string diagrams as primitives. Thanks to the cartesian product, lambda terms can copy and discard variables at will.
3. The (pink) monoidal category $\mathbf{Vect}$ where the computation of the model happens. This can be replaced by any monoidal category $\mathbf{C}$, be it cartesian, compact or otherwise.

**Remark**.: _The equivalence between the lambda calculus with simple types and cartesian closed categories is known as the Curry-Howard-Lambek isomorphism [16, SS1.6]. The correspondence between categorial grammars and closed monoidal categories is due to Lambek [17]._ Thus, higher-order DisCoCat models allow to make a distinction between the resource-sensitive world of **Vect** where computation happens and the cartesian category $\Lambda D$ where we can do arbitrary meta-computation. This may summarised in a slogan: _processes cannot copy, but we can copy processes_. Take the example of quantum circuits: there is no circuit that can copy arbitrary qubits, but we can copy the classical instructions for any quantum circuit.

## 2 Montague semantics as a closed monoidal functor

Before we define HO-DisCoCat and its string-diagram-valued lambda calculus, we first look at the simpler case of standard Montague semantics, defined as a monoidal functor $F:\mathbf{G}\rightarrow\Lambda L$. We adapt the presentation from [18].

As codomain $\Lambda L$, we take the cartesian closed category with objects generated by $L_{0}=\{\tau,\phi\}$ for _terms_ and _formulae_. The generating arrows $L_{1}$ are listed in the table below, they are chosen so that the arrows $f:\tau^{\otimes k}\rightarrow\phi$ in $\Lambda L$ are all the well-formed formulae of first-order logic with $k\geq 0$ free variables. The relations $(f,f^{\prime})\in L_{2}$ between pairs of formulae $f,f^{\prime}:\tau^{\otimes k}\rightarrow\phi$ may be given by any sound and complete deduction system for first-order logic, so that $f=f^{\prime}$ in $\Lambda L$ if and only if $f$ and $f^{\prime}$ are equivalent formulae. The closed monoidal functors are _interpretations_, also called first-order _structures_: they are defined by a set $\llbracket\tau\rrbracket$ called the _universe_ and a set $\llbracket\phi\rrbracket$ of _truth values_, together with an element $\llbracket\text{Alice}\rrbracket\in\llbracket\tau\rrbracket$ for each constant, a function $\llbracket\text{mortal}\rrbracket:\llbracket\tau\rrbracket\rightarrow\llbracket \phi\rrbracket$ for each unary predicate, etc.

\begin{tabular}{c|c c} $L_{1}$ & **symbol** & **type** \\
**constants** & Alice, Bob, ... & $\tau$ \\
**unary predicates** & man, sings, ... & $\tau\rightarrow\phi$ \\
**binary predicates** & needs, sees, ... & $\tau\rightarrow(\tau\rightarrow\phi)$ \\
**nullary operators** & $\top,\bot$ & $\phi$ \\
**unary operators** & $\neg$ & $\phi\rightarrow\phi$ \\
**binary operators** & $\wedge,\vee,\rightarrow$ & $\phi\rightarrow(\phi\rightarrow\phi)$ \\
**quantifiers** & $\forall,\exists$ & $(\tau\rightarrow\phi)\rightarrow\phi$ \\ \end{tabular}

**Remark**.: _We treat the quantifiers $\forall,\exists$ as higher-order functions $(\tau\rightarrow\phi)\rightarrow\phi$ and write $\exists x.u$ for $\exists(\lambda x.u)$. In other words, we define first-order logic formulae as lambda terms where every $\lambda$ is preceded by $\forall$ or $\exists$. Thus, the variables of first-order logic formulae are encoded as variables in lambda terms, with implicit $\alpha$-reductions so that e.g. $(\exists x.Px)=(\exists y.Py)$._

**Remark**.: _The presentation $L$ implicitly depends on a first-order signature which contains all the non-logical symbols (constants and predicates)._

As domain $\mathbf{G}$, we take the free closed monoidal category with objects generated by the grammatical types $\{s,n,p\}$ for _sentence_, _common noun_ and _noun phrase_ respectively, together with the words in some finite _vocabulary_$w\in V$. There is a generating arrow $w\to t$ for each _dictionary entry_, i.e. for each word $w\in V$ of type $t$ as listed in the table below. Now we can define the image of our functor on generating objects: sentences go to formulae, common nouns go to predicates and noun phrases go to functions from predicates to formulae. For example, the function for the noun phrase "no man" takes as input any formula $P(x)$ with a free variable and return the closed formula $\forall x.\neg\text{man}(x)\lor P(x)$.

$$F(s)=\phi\qquad F(n)=\tau\rightarrow\phi\qquad F(p)=(\tau\rightarrow\phi)\to\phi$$

We assume that the objects for each word go to the monoidal unit, i.e. $F(w)=1$ so that the meaning of dictionary entries $w\to t$ is given states $F(w\to t):1\to F(t)$ listed below.

\begin{tabular}{c c c c} Montague semantics & **word**$w$ & **type**$t$ & **meaning**$F(w\to t)$ \\
**proper nouns** & Alice & $p$ & $\lambda P.P(Alice)$ \\
**common nouns** & man & $n$ & $\lambda x.\text{man}(x)$ \\
**adjectives** & big & $n\gets n$ & $\lambda Px.\text{big}(x)\wedge Px$ \\
**determiners** & every & $p\gets n$ & $\lambda PQ.\forall x.Px\to Qx$ \\
**intransitive verbs** & sleeps & $p\to s$ & $\lambda P.P(\lambda x.\text{sleeps}(x))$ \\
**transitive verbs** & kills & $(p\to s)\gets p$ & $\lambda PQ.Q(\lambda x.P(\lambda y.\text{kills}(x,y)))$ \\ \end{tabular}

Again, we can visualise the action of the functor $F:\mathbf{G}\rightarrow\Lambda L$ on the syntax trees for a grammatical sentence by labeling each node with a lambda term. Note how the meanings of determiners "every" and "a" use both the higher-order and cartesian structure of the cartesian closed category $\Lambda L$: they take two predicates $P$ and $Q$, quantify over a variable $x$ of which they make two copies, feeding one to $P$ and the other to $Q$ before combining the resulting formulae.

\begin{tabular}{c c c c} Alice & kills & a & mortal \\ \hline $\lambda P\cdot P(\text{Alice})$ & $\lambda P\cdot Q(\lambda x\cdot P(\lambda y\cdot\text{kills}(x,y)))$ & $\lambda PQ\cdot\exists x\cdot Px\wedge Qx$ & $\lambda x\cdot\text{ mortal}(x)$ \\ \hline $p$ & $(p\to s)\gets p$ & $p\gets n$ & $n$ \\ \cline{3-4}  & & $\lambda Q\cdot\exists x\cdot\text{ mortal}(x)\wedge Qx$ \\ \cline{3-4}  & & $p$ \\ \cline{3-4}  & & $\lambda Q\cdot Q(\lambda x\cdot\exists y\cdot\text{ mortal}(y)\wedge\text{ kills}(x,y))$ & \\ \cline{3-4}  & & & $p\to s$ \\ \cline{3-4}  & & & \\ \cline{3-4}  & & & \\ \cline{3-4}  & & & \\ \end{tabular}

\begin{tabular}{c c c c} Every & big & man & sleeps \\ \cline{3-4}  & & $\lambda Px\cdot\text{big}(x)\wedge Px$ & $\lambda x\,\cdot\text{man}(x)$ & $\lambda P\cdot P(\lambda x\cdot\text{sleeps}(x))$ \\ \cline{3-4}  & & $n\gets n$ & $n$ & $p\to s$ \\ \cline{3-4}  & & $\lambda x\cdot\text{big}(x)\wedge\text{man}(x)$ & \\ \cline{3-4}  & & $n$ & \\ \cline{3-4}  & & & \\ \cline{3-4}  & & $p$ & \\ \cline{3-4}  & & & \\ \end{tabular}

\begin{tabular}{c c c} $p$ & $\forall x\cdot\text{big}(x)\wedge\text{man}(x)\rightarrow\text{sleeps}(x)$ \\ \cline{3-4}  & & $s$ \\ \hline \end{tabular}

 Higher-order DisCoCat as a closed monoidal functor

We can now unpack our main definition: HO-DisCoCat models as closed monoidal functors $F:\mathbf{G}\to\Lambda D$ from a categorial grammar $\mathbf{G}$ to the cartesian closed category $\Lambda D$ generated by $D$, the language of _string diagrams_.

Before we draw any diagram, we fix a monoidal signature $\Sigma=(\Sigma_{0},\Sigma_{1},\mathtt{dom},\mathtt{cod})$, i.e. a pair of sets $\Sigma_{0}$ and $\Sigma_{1}$ for generating _objects_ and _boxes_ together with a pair of functions $\mathtt{dom},\mathtt{cod}:\Sigma_{1}\to T$ from boxes to lists of objects $T=\Sigma_{0}^{\star}=\coprod_{k\in\mathbb{N}}\Sigma_{0}^{k}$, also called _types_. The generating objects of the cartesian closed category $\Lambda D$ are given by pairs of types which encode the input and output of diagrams, i.e. $D_{0}=T\times T$.

\begin{tabular}{r|c c} $D_{1}$ & symbol & type \\
**boxes** & $f\in\Sigma$ & $(x,y)$ \\
**identity** & $\mathrm{id}_{x}$ & $(x,x)$ \\
**composition** & $\circ_{xyz}$ & $(x,y)\to(y,z)\to(x,z)$ \\
**tensor** & $\otimes_{xyzw}$ & $(x,y)\to(z,w)\to(xz,yw)$ \\ \end{tabular}

The generating arrows $D_{1}$ are listed in the table above, they are chosen so that the arrows:

$$f:(z_{1},w_{1})\times\cdots\times(z_{k},w_{k})\to(x,y)\quad\in\Lambda D$$

are all the well-typed string diagrams with $(x,y)\in D_{0}$ as domain, codomain and $k$ free variables for boxes of shape $(z_{i},w_{i})\in D_{0}$. The relations $(f,f^{\prime})\in D_{2}$ between pairs of diagrams are given by the axioms for monoidal categories so that $f=f^{\prime}$ in $\Lambda D$ if and only if the two diagrams are equivalent (i.e. planar isotopic), see [19, Theorem 3.1]. Closed monoidal functors $\llbracket-\rrbracket:\Lambda D\to\mathbf{Set}$ are in one-to-one correspondence with monoidal functors $\llbracket-\rrbracket:F(\Sigma)\to\mathbf{C}$ from the free monoidal category generated by $\Sigma$ into any monoidal category $\mathbf{C}$. In other words, they are defined by the following data:

* an inclusion $\Sigma_{0}\hookrightarrow\mathbf{C}_{0}$ and a morphism $\llbracket f\rrbracket\in\mathbf{C}(x,y)$ for each box $(f:x\to y)\in\Sigma$,
* a _homset_$\mathbf{C}(x,y)=\llbracket(x,y)\rrbracket$ between every pair of types,
* an _identity morphism_$\llbracket\mathrm{id}_{x}\rrbracket\in\mathbf{C}(x,x)$ for each type $x\in T$,
* a _composition function_$\llbracket\circ_{xyz}\rrbracket:\mathbf{C}(x,y)\to\mathbf{C}(y,z)\to\mathbf{C} (y,z)$,
* a _tensor function_$\llbracket\otimes_{xyzw}\rrbracket:\mathbf{C}(x,y)\to\mathbf{C}(z,w)\to\mathbf{ C}(xz,yw)$.

We can recover the standard definition of DisCoCat models in terms of pregroups by taking the HO-DisCoCat model which sends the syntax trees in a categorial grammar to their corresponding pregroup diagrams, which come with an implicit interpretation in $\mathbf{C}=\mathbf{Vect}$. This is based on a functor from closed to _rigid monoidal categories_ which appears in the CCG version of the DisCoCat framework [6].

\begin{tabular}{r|c c c} CCG-to-DisCoCat & **word**$w$ & **type**$t$ & **meaning**$F(w\to t)$ \\ \hline
**proper nouns** & Alice, Bob & $n$ & $\mathrm{Alice},\mathrm{Bob}\in\Sigma$ \\
**transitive verbs** & loves & $(n\to s)\gets n$ & $\lambda fg.(\mathrm{cup}_{N}\otimes\mathrm{id}_{S}\otimes\mathrm{cup}_{N}) \circ(g\otimes\mathrm{loves}\otimes f)$ \\ \end{tabular}

 

**Remark**.: _A similar trick of interpreting syntax trees as functions that return pregroup diagrams is also used in the formalisation of Wittgenstein's language games in terms of functors [20]._

We can also formalise our toy example "very big car" where we define the image of our HO-DisCoCat model $F:\mathbf{G}\rightarrow\Lambda D$ as follows.

\begin{tabular}{c c c c} "very big" = "big big big" & **word**$w$ & **type**$t$ & **meaning**$F(w\to t)$ \\ \hline
**common nouns** & car & $n$ & car $\in\Sigma$ \\
**adjectives** & big & $n\gets n$ & $\lambda x.\text{big}\circ x$ \\
**adverbs** & very & $(n\gets n)\leftarrow(n\gets n)$ & $\lambda fx.ffx$ \\ \end{tabular} Note how we have three different directions in which to compose diagrams:

1. _left-to-right_ using the composition $\circ_{xyz}:(x,y)\times(y,z)\rightarrow(x,z)$ which connects the output of one diagram to the input of another,
2. _top-to-bottom_ using the tensor $\otimes_{xyzw}:(x,y)\times(z,w)\rightarrow(xz,yw)$ which concatenates two diagrams side by side,
3. _inside-out_ using the evaluation $(x,y)\times\left[(x,y)\rightarrow(z,w)\right]\rightarrow(z,w)$ which substitutes one diagram for the free variable in another.

Whereas standard DisCoCat model could play only with the first two directions, it is this extra direction of inside-out composition that makes our higher-order DisCoCat models more flexible. In the next section, we make this extra flexibility more explicit by adding it directly to the signature for our diagrams.



## 4 Adverbs as operators on homsets

Moving away from our toy example to a more realistic model of language, we cannot assume that adverbs can all be given an explicit formula like the one we chose for "very". We propose to represent such second-order3 processes as _boxes with $k$ holes_ that can contain diagrams of a certain shape. Concretely, we define a _monoidal signature with holes_:

Footnote 3: We could imagine going higher still and consider boxes with holes that can fit diagrams with holes themselves, i.e. operators on operators on homsets. We stop at second-order because it is the limit of what we can draw with two-dimensional diagrams.

$$\Sigma=(\Sigma_{0},\Sigma_{1},\mathtt{dom},\mathtt{cod},\mathrm{holes})$$

as a monoidal signature together with a function $\mathrm{holes}:\Sigma_{1}\to(T\times T)^{\star}$ which assigns to each box $(f:x\to y)\in\Sigma$ a list of pairs of types:

$$\mathrm{holes}(f)=\big{(}(z_{1},w_{1}),\ldots,(z_{k},w_{k})\big{)}\in(T\times T )^{\star}$$

for the domain and codomain of the diagrams that can fit in its $k\in\mathbb{N}$ holes. This is drawn as follows:

We may now add some dedicated symbols to our set of generators for the cartesian closed category $\Lambda D$, i.e. the primitives $D_{1}$ of our lambda calculus for diagrams.

\begin{tabular}{c|c c} $D_{1}$ (continued) & symbol & type \\ \hline  & ... & \\
**boxes with holes** & $f\in\Sigma$ & $(z_{1},w_{1})\to\cdots\to(z_{k},w_{k})\to(x,y)$ \\ \end{tabular}

The arrows $f:(z_{1},w_{1})\times\cdots\times(z_{k},w_{k})\to(x,y)$ in $\Lambda D$ are all the well-formed string diagrams where the boxes themselves can contain well-formed string diagrams, again with $k$ boxes as free variables. The closed monoidal functors $\llbracket-\rrbracket:\Lambda D\rightarrow\mathbf{Set}$ are precisely the monoidal categories $\mathbf{C}$ with a $k$-ary _operator on homsets_ for each box $f\in\Sigma$:

$$\llbracket f\rrbracket:\mathbf{C}(z_{1},w_{1})\times\cdots\times\mathbf{C}(z_ {k},w_{k})\to\mathbf{C}(x,y)$$

**Remark**.: _A box with no holes is just a simple box; a nullary operator on homsets is just an element of a homset, i.e. a morphism. Boxes with one hole and unary operators on homsets have also been called bubbles, they were first introduced in [21] to denote the derivative of diagrams. As we will see in the next section, they also allow to formalise negation in Peirce's system beta. Boxes with a list of holes first appeared under the name of quantum combs in [22]. These "open diagrams" have then been formalised in terms of the coend calculus [23, 24]._We can now define the semantics of adverbs like "furiously" as boxes with one hole for a verb, prepositions like "with" as boxes with two holes for nouns, etc.

\begin{tabular}{c c c c} HO-DisCoCat & **word**$w$ & **type**$t$ & **meaning**$F(w\to t)$ \\ \hline
**nouns** & ideas & $n$ & $I\in\Sigma$ \\
**intransitive verbs** & sleep & $n\to s$ & $\lambda x.S\circ x$ \\
**adverbs** & furiously & $(n\to s)\rightarrow(n\to s)$ & $\lambda fx.F(fx)$ \\
**prepositions** & with & $(n\to n)\gets n$ & $\lambda xy.W(y,x)$ \\ \end{tabular}

\begin{tabular}{c c c} Ideas & sleep & furiously \\ \hline
**$I$** & $\lambda x$**.** & $S$ \\ \hline
**$n$** & $n\to s$ & $\lambda gx$**.** & $F$ \\ \end{tabular}

\begin{tabular}{c c} Ideas & sleep & furiously \\ \hline
**$I$** & $\lambda x$**.** & $S$ \\ \hline
**$n$** & $n\to s$ & $\lambda gx$**.** & $F$ \\ \end{tabular}

\begin{tabular}{c c} Ideas & sleep & furiously \\ \hline
**$n\to s$** & $\lambda x$**.** & $\lambda x$**.** \\ \end{tabular}

\begin{tabular}{c c} Ideas & sleep & furiously \\ \hline
**$F$** & $\lambda x$**.** & $S$ \\ \end{tabular}

\begin{tabular}{c c} Ideas & sleep & furiously \\ \hline
**$n\to s$** & $\lambda x$**.** & $\lambda x$**.** \\ \end{tabular}

\begin{tabular}{c c} Ideas & sleep & furiously \\ \hline
**$n\to s$** & $\lambda x$**.** & $\lambda x$**.** \\ \end{tabular}

\begin{tabular}{c c} Ideas & sleep & furiously \\ \hline
**$n\to s$** & $\lambda x$**.** \\ \end{tabular}

\begin{tabular}{c c} Ideas & sleep & furiously \\ \hline
**$F$** & $\lambda x$**.** & $\lambda x$**.** \\ \end{tabular}

\begin{tabular}{c c} Ideas & sleep & furiously \\ \hline
**$n\to s$** & $\lambda x$**.** \\ \end{tabular}

\begin{tabular}{c c} Ideas & sleep & furiously \\ \hline
**$n\to s$** & $\lambda x$**.** \\ \end{tabular}
 

**Remark**.: _Composition and tensor can themselves be thought of as binary operators on homsets, subject to the axioms of monoidal categories:_ boxes with holes are all you need! _This observation can be formalised in terms of_ operads of wiring diagrams _[_25_]__._

## 5 Peirce-Lambek-Montague semantics

In generalising Montague semantics and DisCoCat models, we are in fact going back to their common ancestor: Peirce's _existential graphs_, a formal graphical language of string diagrams for logic. Peirce's existential graphs come in three variants of increasing expressive power:

* _System alpha_, the fragment of system beta with no wires and only scalar boxes, is equivalent to propositional logic and Boolean algebras.
* _System beta_ is the variant we use in this work, it is equivalent to first-order logic.
* _System gamma_ extends system beta with a second unary operator on homsets for the "contingent" modality (i.e. "not necessary") together with axioms that make it sound and complete for various kinds of modal logics.

The translation between Peirce's graphical notation and the traditional one is straightforward. Boxes are predicates and wires are variables, which are implicitly existentially quantified.

Tensor is interpreted as conjunction and spiders as equality of variables. Thus, a scalar diagram with no input or output wires represents a first-order logic formula with no free variables, which we take as our interpretation for sentences. A diagram with not input and one output wire $N$ is a formula with one free variable. We take this as our interpretation for common nouns, i.e.

$$F(s)=(1,1)\qquad\text{and}\qquad F(n)=(1,N)$$

Before we move on to noun phrases and determiners, let us look at a preliminary example taken from Big Shaq's novelty song title "Man's Not Hot", which we interpret as the formula $\exists x.\text{man}(x)\land\neg\text{hot}(x)$.

\begin{tabular}{c c c c} Man's Not Hot & **word**$w$ & **type**$t$ & **meaning**$F(w\to t)$ \\ \hline
**common noun** & Man's & $n$ & $(\text{man}:1\to N)\in\Sigma$ \\
**negation** & Not & $(n\to s)\gets a$ & $\lambda fg.(\neg f)\circ g$ \\
**adjective** & Hot & $a$ & $(\text{hot}:N\to 1)\in\Sigma$ \\ \hline \end{tabular}

\begin{tabular}{c c c} Man's & Not & Hot \\ \hline \end{tabular}
 This is precisely the definition we use to model noun phrases, i.e.

$$F(p)=\prod_{x}(N,x)\rightarrow(1,x)$$

For example, the function $\lambda f.\mathrm{man}\circ f$ for the noun phrase "a man" can take as input any diagram $(N,x)$ and return a state $(1,x)$. In this way, we can apply it to an effect $\mathrm{hot}:(N,1)$ and get a closed formula $\exists x.\mathrm{man}(x)\wedge\mathrm{hot}(x)$, but we can also keep the variable free by applying it to the identity. Finally, we can define the meaning $\lambda fg.g(f(\mathrm{id}_{N})^{T})$ of the copula "is": it takes two noun phrases, applies one to the identity diagram and transposes the result before feeding it to the other. Other verbs are given in the same way, replacing the identity diagram $\mathrm{id}_{N}$ by any predicate.

\begin{tabular}{c c c c} Peirce-Lambek-Montague & **word**$w$ & **type**$t$ & **meaning**$F(w\to t)$ \\ \hline
**common nouns** & man & $n$ & $(\mathrm{man}:1\to N)\in\Sigma$ \\
**proper nouns** & Alice & $p$ & $\lambda f.\mathrm{Alice}\circ f$ \\
**adjectives** & big & $n\gets n$ & $\lambda f.\mathrm{spider}_{2,1}\circ(\mathrm{big}\otimes f)$ \\
**determiners** & no & $p\gets n$ & $\lambda fg.\mathrm{cut}(g\circ f)$ \\
**intransitive verbs** & sleeps & $p\to s$ & $\lambda P.P(\mathrm{sleeps})$ \\
**transitive verbs** & kills & $(p\to s)\gets p$ & $\lambda PQ.Q(P(\mathrm{kills})^{T})$ \\
**copula** & is & $(p\to s)\gets p$ & $\lambda PQ.Q(P(\mathrm{id}_{N})^{T})$ \\ \end{tabular}

\begin{tabular}{c c c c} Alice & kills & a & mortal \\ \hline $\lambda f\cdot$ & $\begin{array}{c}\framebox{$A$}\framebox{$f$}\end{array}$ & $\lambda PQ\cdot Q(P(\framebox{$K$}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|}\phantom{|} \phantom{|}\ $\lambda fg\cdot$$\lambda f\cdot$$g\ 

## Conclusion

Higher-order DisCoCat models are a generalisation of DisCoCat and Montague semantics where the meaning of words is given by lambda terms which output string diagrams. We have given a formal definition in terms of functors $\mathbf{G}\to\Lambda D$ for $\mathbf{G}$ a categorial grammar and $\Lambda D$ the cartesian closed category generated by the language of string diagrams. We defined a concrete instance of our model -- _Peirce-Lambek-Montague semantics_ -- where the string diagrams are Peircean existential graphs. Using DisCoPy, [14] the Python library for applied category theory, the implementation of our formal definition is straightforward, see Appendix A. Giving experimental support for our higher-order DisCoCat models would be a natural next step. Another direction which has been developed recently [26] is to go from sentences to text, formalising the DisCoCirc framework [27] in terms of diagram-valued higher-order functions.

AcknowledgementsThe authors thank Sean Tull, Richie Yeung and Bob Coecke for their insightful support in improving this manuscript.

## References

* [1] Stephen Clark, Bob Coecke, and Mehrnoosh Sadrzadeh. "A Compositional Distributional Model of Meaning". In: _Proceedings of the Second Symposium on Quantum Interaction (QI-2008)_. 2008, pp. 133-140.
* [2] Stephen Clark, Bob Coecke, and Mehrnoosh Sadrzadeh. "Mathematical Foundations for a Compositional Distributional Model of Meaning". In: _A Festschrift for Jim Lambek_. Ed. by J. van Benthem and M. Moortgat. Vol. 36. Linguistic Analysis. 2010, pp. 345-384. arXiv: 1003.4394.
* [3] Giovanni de Felice. "Categorical Tools for Natural Language Processing". PhD thesis. University of Oxford, Dec. 2022. arXiv: 2212.06636.
* [4] Joachim Lambek. "The Mathematics of Sentence Structure". In: _The American Mathematical Monthly_ 65.3 (Mar. 1958), pp. 154-170. doi: 10.1080/00029890.1958.11989160.
* [5] Bob Coecke, Edward Grefenstette, and Mehrnoosh Sadrzadeh. "Lambek vs. Lambek: Functorial Vector Space Semantics and String Diagrams for Lambek Calculus". In: _Ann. Pure Appl. Log._ 164.11 (2013), pp. 1079-1100. doi: 10.1016/j.apal.2013.05.009. arXiv: 1302.0393.
* [6] Richie Yeung and Dimitri Kartsaklis. "A CCG-Based Version of the DisCoCat Framework". In: _ArXiv e-prints_ (May 2021). arXiv: 2105.07720.
* [7] Giovanni de Felice, Konstantinos Meichanetzidis, and Alexis Toumi. "Functorial Question Answering". In: _Proceedings Applied Category Theory 2019, ACT 2019, University of Oxford, UK_. Vol. 323. EPTCS. 2019. doi: 10.4204/EPTCS.323.6.
* [8] Charles Santiago Sanders Peirce. "Prolegomena to an Apology of Pragmaticism". In: _The Monist_ 16.4 (1906), pp. 492-546. JSTOR: 27899680.

Geraldine Brady and Todd H. Trimble. "A String Diagram Calculus for Prediate Logic and C. S. Peirce's System Beta". 1998. url: http://people.cs.uchicago.edu/~brady/beta98.ps.
* [10] Nathan Haydon and Pawel Sobocinski. "Compositional Diagrammatic First-Order Logic". In: _Diagrammatic Representation and Inference_. Ed. by Ahti-Veikko Pietarinen et al. Lecture Notes in Computer Science. Cham: Springer International Publishing, 2020, pp. 402-418. doi: 10.1007/978-3-030-54249-8_32.
* [11] Richard Montague. "Universal Grammar". In: _Theoria_ 36.3 (1970), pp. 373-398. doi: 10.1111/j.1755-2567.1970.tb00434.x.
* [12] Bob Coecke, Giovanni de Felice, Konstantinos Meichanetzidis, and Alexis Toumi. "Foundations for Near-Term Quantum Natural Language Processing". In: _ArXiv e-prints_ (2020). arXiv: 2012.03755.
* [13] Alexis Toumi. "Category Theory for Quantum Natural Language Processing". PhD thesis. University of Oxford, 2022. arXiv: 2212.06615.
* [14] Giovanni de Felice, Alexis Toumi, and Bob Coecke. "DisCoPy: Monoidal Categories in Python". In: _Proceedings of the 3rd Annual International Applied Category Theory Conference, ACT_. Vol. 333. EPTCS, 2020. doi: 10.4204/EPTCS.333.13.
* [15] Johan Bos et al. "Wide-Coverage Semantic Representations from a CCG Parser". In: _COLING 2004: Proceedings of the 20th International Conference on Computational Linguistics_. Geneva, Switzerland: COLING, Aug. 2004, pp. 1240-1246. url: https://aclanthology.org/C04-1180 (visited on 11/29/2023).
* [16] Samson Abramsky and Nikos Tzevelekos. "Introduction to Categories and Categorical Logic". In: _CoRR_ abs/1102.1313 (2011). arXiv: 1102.1313.
* [17] J. Lambek. "Categorial and Categorical Grammars". In: _Categorial Grammars and Natural Language Structures_. Ed. by Richard T. Oehrle, Emmon Bach, and Deirdre Wheeler. Studies in Linguistics and Philosophy. Dordrecht: Springer Netherlands, 1988, pp. 297-317. doi: 10.1007/978-94-015-6878-4_11.
* [18] Jan van Eijck and Christina Unger. _Computational Semantics with Functional Programming_. Cambridge: Cambridge University Press, 2010. doi: 10.1017/CBO9780511778377.
* [19] Peter Selinger. "A Survey of Graphical Languages for Monoidal Categories". In: _New Structures for Physics_ (2010), pp. 289-355. doi: 10.1007/978-3-642-12821-9_4.
* [20] Giovanni de Felice, Elena Di Laore, Mario Roman, and Alexis Toumi. "Functorial Language Games for Question Answering". In: _Proceedings of the 3rd Annual International Applied Category Theory Conference 2020, ACT 2020, Cambridge, USA, 6-10th July 2020_. Ed. by David I. Spivak and Jamie Vicary. Vol. 333. EPTCS. 2020, pp. 311-321. doi: 10.4204/EPTCS.333.21.
* [21] Roger Penrose and Wolfgang Rindler. _Spinors and Space-Time: Volume 1: Two-Spinor Calculus and Relativistic Fields_. Vol. 1. Cambridge Monographs on Mathematical Physics. Cambridge: Cambridge University Press, 1984. doi: 10.1017/CBO9780511564048.

 * [22] G. Chiribella, G. M. D'Ariano, and P. Perinotti. "Quantum Circuit Architecture". In: _Physical Review Letters_ 101.6 (Aug. 2008), p. 060401. doi: 10.1103/PhysRevLett.101.060401.
* [23] Mario Roman. "Coend Calculus and Open Diagrams". In: _ArXiv e-prints_ (Apr. 2020). arXiv: 2004.04526.
* [24] James Hefford and Cole Comfort. "Coend Optics for Quantum Combs". In: _Electronic Proceedings in Theoretical Computer Science_ 380 (Aug. 2023), pp. 63-76. doi: 10.4204/EPTCS.380.4. arXiv: 2205.09027 [quant-ph].
* [25] Donald Yau. _Operads of Wiring Diagrams_. Vol. 2192. Lecture Notes in Mathematics. Cham: Springer International Publishing, 2018. doi: 10.1007/978-3-319-95001-3.
* [26] Jonathon Liu et al. "Discourse Text Circuits From CCG: A Pipeline". In: _to appear_ (2023).
* [27] Bob Coecke. "The Mathematics of Text Structure". In: _Joachim Lambek: The Interplay of Mathematics, Logic, and Linguistics_. Ed. by Claudia Casadio and Philip J. Scott. Cham: Springer International Publishing, 2021, pp. 181-217. doi: 10.1007/978-3-030-66545-6_6.

 Implementation

# Step 1: Define Formula as a subclass of frobenius.Diagram

from discovery import frobenius from discovery.tensor import Dim, Tensor from discovery.cat import Category, factory

@factory class Formula(frobenius.Diagram):  ty_factory = frobenius.PRO # i.e. natural numbers as objects

 def eval(self, size):  return frobenius.Functor(  ob=lambda _ Dim(size),  ar=lambda box: box.data,  cod=Category(Dim, Tensor[bool]))(self)

class Cut(frobenius.Bubble, Formula): pass class Ligature(frobenius.Spider, Formula): pass class Predicate(frobenius.Box, Formula): pass

Id, Formula.bubble_factory = Formula.id, Cut Tensor[bool].bubble = lambda self, **_: self.map(lambda x: not x)

Step 2: Parse natural language sentences using a categorial grammar from discopy.grammar.categorial import Ty, Word, Eval n, p, s = Ty('n'), Ty('p'), Ty('s') # noun, phrase and sentence Alice = Word("Alice", p) big, sleeps = Word("big", n << n), Word("sleeps", p >> s) man, island = (Word(noun, n) for noun in ("man", "island")) kills,_is = (Word(verb, (p >> s) << p) for verb in ("kills", "is")) no, every, some = (Word(det, p << n) for det in ("no", "every", "some")) Alice_kills_a_mortal = (Alice @ kills @ some @ man  >> p @ ((p >> s) << p) @ Eval(p << n)  >> p @ Eval((p >> s) << p) >> Eval(p >> s)) every_big_man_sleeps = (every @ big @ man @ sleeps  >> ((p << n) @ Eval(n << n) >> Eval(p << n))   @ (p >> s) >> Eval(p >> s)) no_man_is_an_island = (no @ man @ _is @ some @ island  >> Eval(p << n) @ ((p >> s) << p) @ Eval(p << n)  >> p @ Eval((p >> s) << p) >> Eval(p >> s)) from random import choice

size = 42 # Generating a random interpretation to test our model random_bits = lambda n=size: [choice([True, False]) for _ in range(n)]

is_killed_by = [random_bits() for _ in range(size)] unary_predicates = is_Alice, is_man, is_island, is_big, is_sleeping = [ random_bits() for _ in range(5)]

K = Predicate("K", 1, 1, data=is_killed_by) A, M, I, B, S = (Predicate(P, 0, 1, data)  for P, data in zip("AMIBS", unary_predicates))

# Step 3: Higher-order DisCoCat as a closed functor into Python functions

from typing import Callable

from discopy import closed from discopy.python import Function

F = closed.Functor(  cod=Category(tuple[type, ...], Function),  ob={s: Formula, n: Formula, p: Callable[[Formula], Formula]},  ar={Alice: lambda: lambda f: A >> f,  sleeps: lambda: lambda P: P(S.dagger()),  man: lambda: M, island: lambda: I,  big: lambda: lambda f: f @ B >> Ligature(2, 1, frobenius.PRO(1)),  _is: lambda: lambda P: lambda Q: Q(P(Id(1)).dagger()),  kills: lambda: lambda P: lambda Q: Q(P(K).dagger()),  no: lambda: lambda f: lambda g: (f >> g).bubble(),  some: lambda: lambda f: lambda g: f >> g,  every: lambda: lambda f: lambda g: (f >> g.bubble()).bubble())

evaluate = lambda sentence: bool(F(sentence)().eval(size))

assert evaluate(Alice_kills_a_mortal) == any(  is_man[y] and is_killed_by[y][x] and is_Alice[x]  for x in range(size) for y in range(size)) assert evaluate(every_big_man_sleeps) == all(  not (is_big[x] and is_man[x]) or is_sleeping[x] for x in range(size)) assert evaluate(no_man_is_an_island) == all(  not is_man[x] or not is_island[x] for x in range(size))

This implementation is also available as a notebook:

https://docs.discopy.org/en/main/notebooks/higher-order-discocat.html 